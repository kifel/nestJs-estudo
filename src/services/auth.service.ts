import {
  Injectable,
  NotFoundException,
  UnauthorizedException,
} from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { RefreshToken } from '@prisma/client';
import * as bcrypt from 'bcrypt';
import { randomUUID } from 'node:crypto';
import { PrismaService } from 'src/config/database/prisma.service';
import { RefreshTokenRequest } from 'src/dtos/auth.dto';
import { UserResponse, UserResponseLogin } from 'src/dtos/user-response.dto';
import { UserRole } from 'src/enums/UserRole';
import { UserFromJwt } from 'src/models/user-from-jwt';
import { UserPayload } from 'src/models/user-payload';
import { AuthRepository } from 'src/repositories/auth-repository';
import { UserRepository } from 'src/repositories/user-repository';

// [ ] Melhorar essa classe adicionando o findById, assim que for implementado essa função no user service

@Injectable()
export class AuthService implements AuthRepository {
  constructor(
    private readonly userRepository: UserRepository,
    private readonly prisma: PrismaService,
    private readonly jwtService: JwtService,
  ) {}

  /**
   * This function refreshes a user's access token using their refresh token if it is valid and belongs
   * to the correct user.
   * @param {RefreshTokenRequest} token - A RefreshTokenRequest object containing the refresh token and
   * user ID.
   * @returns a Promise that resolves to a UserResponseLogin object.
   */
  async refreshToken(token: RefreshTokenRequest): Promise<UserResponseLogin> {
    const refreshToken = await this.prisma.refreshToken.findFirst({
      where: {
        token: token.refreshToken,
      },
    });
    // Verifica se o token foi encontrado
    if (refreshToken) {
      // Verifica se o token pertence ao usuário que foi informado e se ele esta expirado
      if (!this.isRefreshTokenExpired(refreshToken)) {
        if (refreshToken.userId === token.userId) {
          const user = await this.prisma.user.findUnique({
            where: {
              id: token.userId,
            },
            include: {
              roles: {
                select: {
                  name: true,
                },
              },
            },
          });
          await this.prisma.refreshToken.delete({
            where: {
              id: refreshToken.id,
            },
          });

          return await this.generateToken(user);
        }
      }
    }
    throw new UnauthorizedException('Dados inválidos.');
  }

  /**
   * This function checks if a refresh token has expired.
   * @param {RefreshToken} refreshToken - RefreshToken is an object that contains information about a
   * refresh token, including its expiry date.
   * @returns a boolean value indicating whether the refresh token has expired or not. If the current
   * date and time is greater than the expiry date of the refresh token, then it is considered expired
   * and the function returns true. Otherwise, it returns false.
   */
  private isRefreshTokenExpired(refreshToken: RefreshToken): boolean {
    const currentDateTime = new Date();
    const expiryDate = new Date(refreshToken.expiryDate);

    return currentDateTime > expiryDate;
  }

  /**
   * This function generates a JWT access token and a refresh token for a given user.
   * @param {UserResponse} user - A UserResponse object that contains information about a user, such as
   * their ID and name.
   * @returns The function `generateToken` returns a Promise that resolves to an object of type
   * `UserResponseLogin`. This object contains two properties: `accessToken` and `refreshToken`. The
   * `accessToken` is a JSON Web Token (JWT) that is generated using the `jwtService` and contains the
   * user's ID and name as payload. The `refreshToken` is generated by calling the `createRefresh
   */
  async generateToken(user: UserResponse): Promise<UserResponseLogin> {
    const payload: UserPayload = {
      sub: user.id,
      name: user.name,
    };
    const jwtToken = this.jwtService.sign(payload);

    const refreshToken = await this.createRefreshTokenToken(user);

    return {
      accessToken: jwtToken,
      refreshToken: refreshToken,
    };
  }

  /**
   * This is an async function that validates a user's name and password, and returns a UserResponse
   * object with the user's information if the validation is successful, or throws an
   * UnauthorizedException if the validation fails.
   * @param {string} name - A string representing the username of the user being validated.
   * @param {string} password - The password parameter is a string that represents the password entered
   * by the user for authentication.
   * @returns The function `validateUser` returns a `Promise` that resolves to a `UserResponse` object if
   * the user is validated successfully, or throws an `UnauthorizedException` if the user is not
   * validated. The `UserResponse` object is a copy of the `existUser` object with the `password`
   * property set to `undefined`.
   */
  async validateUser(name: string, password: string): Promise<UserResponse> {
    const existUser = await this.userRepository.findByName(name);

    if (existUser) {
      const isPasswordValid = await bcrypt.compare(
        password,
        existUser.password,
      );
      if (isPasswordValid) {
        return {
          ...existUser,
          password: undefined,
        };
      }
    }
    throw new UnauthorizedException('Usuário ou senha inválidos.');
  }

  /**
   * This function creates a refresh token for a user with a 30-day expiry date.
   * @param {UserResponse} user - The `user` parameter is of type `UserResponse`, which is likely an
   * object containing information about a user, such as their ID, name, email, etc. This parameter is
   * used to associate the refresh token with a specific user in the database.
   * @returns a string which is the token generated for the refresh token.
   */
  private async createRefreshTokenToken(user: UserResponse): Promise<string> {
    const agora = new Date();
    const trintaDiasDepois = new Date(
      agora.getTime() + 30 * 24 * 60 * 60 * 1000,
    );
    const refreshToken = await this.prisma.refreshToken.create({
      data: {
        token: randomUUID(),
        userId: user.id,
        expiryDate: trintaDiasDepois,
      },
    });
    return refreshToken.token;
  }

  /**
   * This function validates if a user has the required roles by checking their roles against a list of
   * required roles.
   * @param {UserFromJwt} user - The user object containing information about the user obtained from a
   * JWT (JSON Web Token).
   * @param {UserRole[]} requiredRoles - An array of UserRole enums representing the roles that the
   * user must have in order to pass the validation.
   * @returns A boolean value indicating whether the user has any of the required roles or not.
   */
  async validateRoles(
    user: UserFromJwt,
    requiredRoles: UserRole[],
  ): Promise<boolean> {
    const userLogged = await this.prisma.user.findUnique({
      where: {
        id: user.id,
      },
      include: {
        roles: {
          select: {
            name: true,
          },
        },
      },
    });
    if (!userLogged) {
      throw new NotFoundException('Usuário não encontrado');
    }

    const roles = userLogged.roles.map((role) => role.name);

    const hasRequiredRole = requiredRoles.some((requiredRole) =>
      roles.includes(requiredRole),
    );

    return hasRequiredRole;
  }
}
